import {
  Directive,
  ElementRef,
  inject,
  AfterViewInit,
  OnDestroy,
  PLATFORM_ID,
} from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { IconService } from '../../../core/services/icon.service';
import { IconifyLoadingService } from '../../../core/services/iconify-loading.service';

/**
 * Directive that converts inline icon placeholders to Iconify web components
 * 
 * Design decisions:
 * - Post-processes HTML to replace placeholder spans with iconify-icon elements
 * - Uses IconService for icon name conversion and fallback support
 * - Supports all Iconify libraries (Game Icons, Lucide, Font Awesome, etc.)
 * - Uses same architectural pattern as WikiLinkDirective (data attributes + post-processing)
 * - Handles cascading fallback if primary icon fails to load
 * - Observes DOM mutations to handle dynamically added content
 * - Follows Single Responsibility Principle
 * 
 * Usage:
 * Applied to containers with markdown content that may contain inline icons
 * 
 * Markdown syntax:
 * :icon:GiSword:              → Game Icons sword
 * :icon:LuHeart|24:           → Lucide heart, 24px
 * :icon:heart|20|red:         → Defaults to Game Icons, 20px, red color
 * 
 * HTML placeholder (generated by MarkdownService):
 * <span class="inline-icon" data-icon="GiSword"></span>
 * <span class="inline-icon" data-icon="LuHeart" data-size="24"></span>
 * <span class="inline-icon" data-icon="heart" data-size="20" data-color="red"></span>
 * 
 * Final output (after directive processes):
 * <iconify-icon icon="game-icons:sword" width="1em" height="1em"></iconify-icon>
 */
@Directive({
  selector: '[appInlineIcon]',
  standalone: true,
})
export class InlineIconDirective implements AfterViewInit, OnDestroy {
  private readonly elementRef = inject(ElementRef);
  private readonly iconService = inject(IconService);
  private readonly iconifyLoadingService = inject(IconifyLoadingService);
  private readonly platformId = inject(PLATFORM_ID);
  private readonly isBrowser = isPlatformBrowser(this.platformId);

  private mutationObserver: MutationObserver | null = null;

  ngAfterViewInit(): void {
    // Only run in browser (not during SSR)
    if (!this.isBrowser) {
      return;
    }

    // Wait for Iconify to be available before processing icons
    this.iconifyLoadingService.waitForIconify().then(() => {
      // Test if Iconify API is accessible
      this.iconifyLoadingService.testIconifyConnection();
      
      // Process icons and set up observer once Iconify is ready (replaces arbitrary 100ms setTimeout)
      this.iconifyLoadingService.executeWhenReady(() => {
        // Process any existing inline icon placeholders
        this.processInlineIcons();

        // Set up observer to handle dynamically added content
        this.setupMutationObserver();
      }, 0);
    });
  }

  // Iconify loading logic moved to shared IconifyLoadingService

  ngOnDestroy(): void {
    if (this.mutationObserver) {
      this.mutationObserver.disconnect();
    }
  }

  /**
   * Sets up a MutationObserver to watch for DOM changes
   * Processes new inline icon placeholders when content is dynamically added
   */
  private setupMutationObserver(): void {
    const element = this.elementRef.nativeElement;

    this.mutationObserver = new MutationObserver(() => {
      this.processInlineIcons();
    });

    this.mutationObserver.observe(element, {
      childList: true,
      subtree: true,
    });
  }

  /**
   * Finds all inline icon placeholders and converts them to iconify-icon elements
   */
  private processInlineIcons(): void {
    const element = this.elementRef.nativeElement;
    const iconPlaceholders = element.querySelectorAll('.inline-icon');

    iconPlaceholders.forEach((element: Element) => {
      this.convertPlaceholderToIcon(element as HTMLElement);
    });
  }

  /**
   * Converts a single placeholder span to an iconify-icon web component
   * 
   * @param placeholder - The span element with data-icon attribute
   */
  private convertPlaceholderToIcon(placeholder: HTMLElement): void {
    // Check if already converted (shouldn't happen, but defensive coding)
    if (placeholder.hasAttribute('data-processed')) {
      return;
    }

    // Mark as processed to avoid duplicate processing
    placeholder.setAttribute('data-processed', 'true');

    // Extract icon configuration from data attributes
    const iconName = placeholder.getAttribute('data-icon');
    const size = placeholder.getAttribute('data-size') || '';
    const color = placeholder.getAttribute('data-color') || '';

    if (!iconName) {
      console.warn('Inline icon placeholder missing data-icon attribute');
      return;
    }

    // Convert icon name using IconService (handles prefix conversion, auto-correction)
    const iconifyName = this.iconService.convertToIconifyFormat(iconName);
    
    if (!iconifyName) {
      console.warn(`[Inline Icon] Could not convert icon name: ${iconName}`);
      // Use fallback icon
      const fallbackIcon = this.iconService.getFallbackIcon();
      this.createAndInsertIcon(placeholder, fallbackIcon, size, color);
      return;
    }

    console.debug(`[Inline Icon] Processing icon: ${iconName} → ${iconifyName}`);
    
    // Create and insert the icon element
    this.createAndInsertIcon(placeholder, iconifyName, size, color);
  }

  /**
   * Creates an iconify-icon element and replaces the placeholder
   * 
   * @param placeholder - The placeholder span to replace
   * @param iconifyName - The icon name in Iconify format (e.g., 'game-icons:sword')
   * @param size - Optional size in pixels
   * @param color - Optional color
   */
  private createAndInsertIcon(
    placeholder: HTMLElement,
    iconifyName: string,
    size: string,
    color: string
  ): void {
    // Create iconify-icon web component
    const iconElement = document.createElement('iconify-icon');
    
    // Set icon name
    iconElement.setAttribute('icon', iconifyName);
    
    // Set size (default to 1em for inline sizing)
    const sizeValue = size ? `${size}px` : '1em';
    iconElement.setAttribute('width', sizeValue);
    iconElement.setAttribute('height', sizeValue);
    
    // Set color (default to currentColor to inherit text color)
    const colorValue = color || 'currentColor';
    iconElement.style.color = colorValue;
    
    // Set display properties for proper inline alignment
    iconElement.style.display = 'inline-flex';
    iconElement.style.verticalAlign = 'middle';
    iconElement.style.alignItems = 'center';
    iconElement.style.justifyContent = 'center';
    iconElement.style.minWidth = sizeValue;
    iconElement.style.minHeight = sizeValue;
    
    // Replace placeholder with icon element
    placeholder.replaceWith(iconElement);
    
    // Optional: Verify icon loaded (only in development mode for debugging)
    // This is purely informational - icons will still work even if this reports failure
    if (typeof window !== 'undefined' && (window as any).ngDevMode) {
      // NECESSARY: Check after delay to allow icon to load asynchronously
      this.iconifyLoadingService.checkIconLoaded(iconElement, 5000, (loaded) => {
        if (!loaded) {
          console.debug(`[Inline Icon] Still loading: ${iconifyName} (or doesn't exist)`);
          console.debug('  Check: https://icon-sets.iconify.design/' + iconifyName.replace(':', '/'));
        }
      });
    }
  }
}

